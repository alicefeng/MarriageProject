<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <script type="text/javascript" src="http://d3js.org/d3.v3.min.js"></script>
		<script type="text/javascript" src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
        <style>
			
			h1 {
				font: 24px helvetica;
			}

    		p {
        		font: 12px helvetica;
        		width: 800px;
    		}

    		text {
    			font: 11px helvetica;
    		}

    		.axisLabel text {
    			font-style: italic;
    		}

			.d3-tip {
                position: absolute;
				left: 600px;
				top: 100px;
                pointer-events: none;
				font: 12px sans-serif;
				background-color: #ffffff;
				border: 1px solid;
				padding: 0px 5px;
				border-radius: 5px;
            }
			
			.d3-tip ul {
				list-style: none;
				padding-left: 0;
			}

			.occGroup {
				font: 12px helvetica;
			}

			.occGroup:hover {
				fill: orange;
			}

        </style>
    </head>
    
    <body>
        
		<h1>Who Marries Whom? </h1>

		<p>What jobs do couples tend to hold? </p>

        <script type="text/javascript">

		var w = 1200,
			h = 850,
			padding_top = 50
			padding_bottom = 40;	

		var svg = d3.select("body")
			.append("svg")
			.attr("width", w)
			.attr("height", h);
		
		d3.json("data/pairings.json", function(error, data) {
			console.log(data);
		
			// create scale based on occupation rank
			yscale = d3.scale.linear()
				.domain([d3.min(data, function(d) { return d.Spouse1Rank; }), d3.max(data, function(d) { return d.Spouse1Rank; }) ])
				.range([padding_top, h-padding_bottom]) ;

			// store the horizontal position of the two lists as variables
			var malex = d3.max(data, function(d) { return d.Spouse1Job.length; }) * 7;
			var femalex = w - (d3.max(data, function(d) { return d.Spouse1Job.length; }) * 7);




			//print each occupation group positioned based on its score
			var occGroupTextLeft = svg.selectAll("text")
				.data(data)
				.enter()
				.append("text")
				.attr("class", "occGroup")
				.attr("x", function(d) { if(d.Spouse1Sex == "Male") { return malex; }
										 else { return femalex; } })
				.attr("y", function(d) { return yscale(d.Spouse1Rank); })
				.style("text-anchor", function(d) { if(d.Spouse1Sex == "Female") { return "begin"; }
													else { return "end"; } })
				.text(function(d) { return d.Spouse1Job; })
				.on("mouseover", function(d) { return drawLines(d); } )
				.on("mouseout", function(d) { return eraseLines(d); });

			// create flat dataset based on selected occupation and sex to draw lines for its pairings
			var subdata = function(SelectedJob) {
				var flatdata = [];
				for(i = 0; i < SelectedJob.Spouse2Jobs.length; i++) {
					flatdata.push({Spouse1Job: SelectedJob.Spouse1Job,
								   Spouse1Sex: SelectedJob.Spouse1Sex,
								   Spouse1Rank: SelectedJob.Spouse1Rank,
								   Spouse2Job: SelectedJob.Spouse2Jobs[i].Spouse2Job,
								   Spouse2Sex: SelectedJob.Spouse2Jobs[i].Spouse2Sex,
								   Spouse2Rank: SelectedJob.Spouse2Jobs[i].Spouse2Rank,
								   NumPairings: SelectedJob.Spouse2Jobs[i].NumPairings });
				}
				//console.log(flatdata);
				return(flatdata);
			}

			// draw lines between pairings
			var drawLines = function(selectedJob) {

				// create scale mapping proportion of each specific pairing out of all pairings for the selected occupation to stroke width
				wscale = d3.scale.linear()
					.domain([d3.min(subdata(selectedJob), function(d) { return d.NumPairings; }), 
							 d3.max(subdata(selectedJob), function(d) { return d.NumPairings; }) ])
					.range([1, 6]);

				var pairinglines = svg.selectAll("line")
					.data(subdata(selectedJob))
					.enter()
					.append("line")
					.attr("x1", function(d) { if(d.Spouse1Sex == "Male") { return malex + 5; }
											 else { return femalex - 5; } })
					.attr("x2", function(d) { if(d.Spouse1Sex == "Male") { return femalex - 5; }
											 else { return malex + 5; } })
					.attr("y1", function(d) { return yscale(d.Spouse1Rank) - 4; })     
					.attr("y2", function(d) { return yscale(d.Spouse2Rank) - 4; })                      
					.attr("stroke", "gray")
					.attr("stroke-width", function(d) { if(d.NumPairings >= 30) { return wscale(d.NumPairings); }
														else { return 0; } })  //only display lines when 30 or more couples are observed
					.attr("stroke-linecap", "round")
					.attr("fill", "none"); 	
					
				return pairinglines;			
			}

			// delete lines
			var eraseLines = function(selectedJob) {
				var hidelines = svg.selectAll("line")
					.data({})
					.exit()
					.remove();

				return hidelines;
			}




			// label axes
			var axisLabels = svg.append("g")
				.attr("class", "axisLabel");

			axisLabels.append("text")
				.attr("x", malex)
				.attr("y", 10)
				.style("text-anchor", "end")
				.text("Husband's Occupation");

			axisLabels.append("text")
				.attr("x", femalex)
				.attr("y", 10)
				.text("Wife's Occupation");

			axisLabels.append("text")
				.attr("x", w/2)
				.attr("y", 30)
				.style("text-anchor", "middle")
				.text("Higher Paying Occupations with More Highly Educated Workers");

			axisLabels.append("text")
				.attr("x", w/2)
				.attr("y", h-30)
				.style("text-anchor", "middle")
				.text("Lower Paying Occupations with Less Educated Workers");
		}); 

        </script>
        
    </body>

</html>
